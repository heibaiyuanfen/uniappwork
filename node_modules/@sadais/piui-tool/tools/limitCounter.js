import guid from './guid'
// 欧几里得算法求最大公因数
function gcd(a,b){
  return b === 0?a:gcb(b,a%b)
}
export default (function(){
  const subscriberStack = {}
  let timer = null
  let needReset = false
  // 初始化唯一定时器，保证定时器的循环时间能同时满足所有任务
  function initInterval(){
    // 获取所有任务限时的最大公因数
    let keys = Object.keys(subscriberStack)
    let gys = subscriberStack[keys[0]].time
    keys.forEach(key => {
      gys = gcd(gys,subscriberStack[key].time)
    })
    clearInterval(timer)
    timer = setInterval(()=>{
      let failCount = 0
      keys.forEach(key => {
        const subscriber = subscriberStack[key]
        if(!subscriber) {
          // 订阅者不存在时，说明当前key对应的任务已被注销，失败次数+1并且跳出当前循环
          failCount ++
          return false
        }
        // 当任务满足计数条件后，触发任务回调，重置任务计数
        if(subscriber.count >= subscriber.maxCount){
          subscriber.cb()
          subscriber.count = 0
        }
      })
      if(needReset){
        initInterval()
        needReset = false
      }
      // 当失败次数等于当前记录在案的所有任务数时，说明所有任务已被注销，清除定时器
      if(failCount === keys.length){
        clearInterval(timer)
        timer = null
      }
    },gys * 1000)
  }
  return {
    subscribe(limitCount = 0,limitTime = 0,reachCallback = ()=>{}){
      const uuid = guid()
      subscriberStack[uuid] = {
        count:0,
        maxCount:limitCount,
        time:limitTime,
        cb:reachCallback
      }
      if(timer){
        needReset = true
      } else {
        initInterval()
      }
      return uuid
    },
    unsubscribe(uuid){
      if(!uuid || !subscriberStack[uuid]){
        return console.error("Can't match any subscriber with uuid:"+uuid)
      }
      delete subscriberStack[uuid]
    },
    trigger(uuid){
      if(!uuid || !subscriberStack[uuid]){
        return console.error("Can't match any subscriber with uuid:"+uuid)
      }
      subscriberStack[uuid].count++ 
    }
  }
})()