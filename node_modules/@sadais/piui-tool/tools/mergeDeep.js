/*
 * @Author: zhangzhenfei
 * @Date: 2021-08-14 11:17:48
 * @LastEditTime: 2021-09-02 15:17:21
 * @LastEditors: zhangzhenfei
 * @Description: 深度合并
 * @FilePath: /piui-doc/piui-tool/tools/mergeDeep.js
 */

var isMergeableObject = function isMergeableObject(value) {
  return isNonNullObject(value) && !isSpecial(value)
}

function isNonNullObject(value) {
  return !!value && typeof value === 'object'
}

function isSpecial(value) {
  var stringValue = Object.prototype.toString.call(value)

  return (
    stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value)
  )
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7

function isReactElement(value) {
  return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
  return Array.isArray(val) ? [] : {}
}

function cloneUnlessOtherwiseSpecified(value, options) {
  return options.clone !== false && options.isMergeableObject(value)
    ? mergeDeep(emptyTarget(value), value, options)
    : value
}

function defaultArrayMerge(target, source, options) {
  return target.concat(source).map(function(element) {
    return cloneUnlessOtherwiseSpecified(element, options)
  })
}

function getMergeFunction(key, options) {
  if (!options.customMerge) {
    return mergeDeep
  }
  var customMerge = options.customMerge(key)
  return typeof customMerge === 'function' ? customMerge : mergeDeep
}

function getEnumerableOwnPropertySymbols(target) {
  return Object.getOwnPropertySymbols
    ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return target.propertyIsEnumerable(symbol)
      })
    : []
}

function getKeys(target) {
  if (!target) return []
  return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
}

function propertyIsOnObject(object, property) {
  try {
    return property in object
  } catch (_) {
    return false
  }
}

// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
  return (
    propertyIsOnObject(target, key) && // Properties are safe to merge if they don't exist in the target yet,
    !(
      (Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key)) // unsafe if they exist up the prototype chain,
    )
  ) // and also unsafe if they're nonenumerable.
}

function mergeObject(target, source, options) {
  var destination = {}
  if (options.isMergeableObject(target)) {
    getKeys(target).forEach(function(key) {
      destination[key] = cloneUnlessOtherwiseSpecified(target[key], options)
    })
  }
  getKeys(source).forEach(function(key) {
    if (propertyIsUnsafe(target, key)) {
      return
    }

    if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
      destination[key] = getMergeFunction(key, options)(target[key], source[key], options)
    } else {
      destination[key] = cloneUnlessOtherwiseSpecified(source[key], options)
    }
  })
  return destination
}

/**
 * 深度合并对象，支持数组
 * 可使用 `.all` 合并多个对象，此时第一个参数必须为数组
 * @param {*} target
 * @param {*} source
 * @param {*} options
 * @returns {Object} 合并后的对象
 * @example
 * const foobar = { foo: { bar: 3 } }
 * const foobaz = { foo: { baz: 4 } }
 * const bar = { bar: 'yay!' }
 * merge.all([ foobar, foobaz, bar ]) // => { foo: { bar: 3, baz: 4 }, bar: 'yay!' }
 * @example
 * `options` 接收一个对象，对象属性有: `arrayMerge` , `isMergeableObject` , `customMerge`
 *
 * 1、`arrayMerge` ： 合并两个数组，此时前两个入参须为数组。 `overwriteMerge` 表示完全覆写，用source覆盖target, `combineMerge` 表示会合并两个数组中相同索引的对象。
 * ```javascript
 * merge(
 * [1, 2, 3],
 * [3, 2, 1],
 * { arrayMerge: overwriteMerge }
 * ) // => [3, 2, 1]
 * merge(
 * [{ a: true }],
 * [{ b: true }, 'ah yup'],
 * { arrayMerge: combineMerge }
 * )
 * ```
 * 2、`isMergeableObject` : 如果您只想克隆普通对象的属性，而忽略所有“特殊”类型的实例化对象，这是你可能就需要 `is-plain-object` 了。
 * ```javascript
 * const isPlainObject = require('is-plain-object')
 *
 * function SuperSpecial() {
 * this.special = 'oh yeah man totally'
 * }
 *
 * const instantiatedSpecialObject = new SuperSpecial()
 *
 * const target = {
 *  someProperty: {
 *    cool: 'oh for sure'
 *  }
 * }
 *
 * const source = {
 *  someProperty: instantiatedSpecialObject
 * }
 *
 * const customMergeOutput = merge(target, source, {
 *    isMergeableObject: isPlainObject
 * })
 *
 * customMergeOutput.someProperty.cool // => undefined
 * customMergeOutput.someProperty.special // => 'oh yeah man totally'
 * customMergeOutput.someProperty instanceof SuperSpecial // => true
 * ```
 *
 * 3、 `customMerge` : 指定一个函数，该函数可用于根据属性名称覆盖默认合并行为。 `customMerge` 函数将传递每个属性的键名，并返回用于合并该属性value值的函数。它也可能返回 undefined，在这种情况下将使用默认合并行为。
 * ```javascript
 * const alex = {
 *     name: {
 *         first: 'Alex',
 *         last: 'Alexson'
 *     },
 *     pets: ['Cat', 'Parrot']
 * }
 *
 * const tony = {
 *     name: {
 *         first: 'Tony',
 *         last: 'Tonison'
 *     },
 *     pets: ['Dog']
 * }
 *
 * const mergeNames = (nameA, nameB) => `${nameA.first} and ${nameB.first}`
 *
 * const options = {
 *     customMerge: (key) => {
 *         if (key === 'name') {
 *             return mergeNames
 *         }
 *     }
 * }
 *
 * const result = merge(alex, tony, options)
 *
 * result.name // => 'Alex and Tony'
 * result.pets // => ['Cat', 'Parrot', 'Dog']
 * ```
 */
function mergeDeep(target, source, options) {
  options = options || {}
  options.arrayMerge = options.arrayMerge || defaultArrayMerge
  options.isMergeableObject = options.isMergeableObject || isMergeableObject
  // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
  // implementations can use it. The caller may not replace it.
  options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified

  var sourceIsArray = Array.isArray(source)
  var targetIsArray = Array.isArray(target)
  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray

  if (!sourceAndTargetTypesMatch) {
    return cloneUnlessOtherwiseSpecified(source, options)
  } else if (sourceIsArray) {
    return options.arrayMerge(target, source, options)
  } else {
    return mergeObject(target, source, options)
  }
}

mergeDeep.all = function(array, options) {
  if (!Array.isArray(array)) {
    throw new Error('first argument should be an array')
  }

  return array.reduce(function(prev, next) {
    return mergeDeep(prev, next, options)
  }, {})
}

export default mergeDeep
