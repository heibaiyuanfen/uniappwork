import uni from './native'
import { isFunction } from './lang'

/**
 * 将对象序列化成url字符串
 * @param  {Object} obj={} 参数对象
 * @param  {Boolean} encodeURI=true 对象值使用编码
 * @param  {String} preConnectChat=? url前连接字符串，如果为空则不连接
 * @return {String} 转换之后的url参数
 */
export function objToUrl(obj = {}, encodeURI = true, preConnectChat = '?') {
  const result = Object.keys(obj).map(prop => {
    const value = encodeURI ? encodeURIComponent(obj[prop]) : obj[prop]
    return `${prop}=${value}`
  })
  return result.length ? preConnectChat + result.join('&') : ''
}

/**
 * 将url字符串解析成对象
 * @param  {String} str='' 带url参数的地址
 * @param  {Boolean} decodeURI=true 使用解码
 * @return {Object} 转换之后的url参数
 */
export function urlToObj(str = '', decodeURI = true) {
  const strSplits = str.split('?')
  const query = strSplits.length === 2 ? strSplits[1] : str
  const params = query.split('&')
  const result = params.reduce((obj, param) => {
    const paramObj = param.split('=')
    const name = paramObj[0]
    const value = paramObj[1] || ''
    obj[name] = decodeURI ? decodeURIComponent(value) : value
    return obj
  }, {})
  return result || {}
}

/**
 * 对 Object Params Props 进行decode
 * @param {Object} params={} params
 * @return {Object} 转换之后的params
 */
export function decodeParams(params = {}) {
  const convertObject = {}
  for (const paramObject of Object.keys(params)) {
    convertObject[paramObject] = decodeURIComponent(params[paramObject])
  }
  return convertObject
}

let routing = false // 控制重复打开页面
const routingMethods = ['navigateTo', 'redirectTo', 'reLaunch', 'switchTab'] // 需要路由控制的方法

export function _openInterceptor(method, url, params, callback = {}, events = {}) {
  if (routing && routingMethods.includes(method)) return
  if (url.indexOf('/') !== 0) {
    url = '/' + url
  }
  const stringParams = objToUrl(params)
  url = url + (url.indexOf('?') !== -1 ? stringParams.replace('?', '&') : stringParams)
  uni.hideKeyboard()
  console.log('使用导航：', method, url, params)
  const { success, fail, complete } = callback
  return new Promise((resolve, reject) => {
    if (routingMethods.includes(method)) routing = true
    uni[method]({
      url,
      events,
      success: res => {
        isFunction(success) && success(res)
      },
      fail: res => {
        isFunction(fail) && fail(res)
      },
      complete: res => {
        routing = false
        isFunction(complete) && complete(res)
        const isSuccess = res.errMsg && res.errMsg.includes(':ok')
        isSuccess ? resolve(res) : reject(res)
      }
    })
  })
}

/**
 * 保留当前页面，跳转到应用内的某个页面
 * @param {String} url 页面路径
 * @param {Object} params={} 页面参数
 * @param {Object} callback={success,fail,complete} 回调函数
 * @param {Object} events = {} 事件对象
 * @return {Promise} 跳转成功或失败的Promise
 */
export function navigateTo(url, params = {}, callback = {}, events = {}) {
  return _openInterceptor('navigateTo', url, params, callback, events)
}

/**
 * 关闭当前页面，跳转到应用内的某个页面
 * @param {String} url 页面路径
 * @param {Object} params={} 页面参数
 * @param {Object} callback={success,fail,complete} 回调函数
 * @return {Promise} 跳转成功或失败的Promise
 */
export function redirectTo(url, params = {}, callback = {}) {
  return _openInterceptor('redirectTo', url, params, callback)
}

/**
 * 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面
 * @param {String} url 页面路径
 * @param {Object} params={} 页面参数
 * @param {Object} callback={success,fail,complete} 回调函数
 * @return {Promise} 跳转成功或失败的Promise
 */
export function switchTab(url, params = {}, callback = {}) {
  return _openInterceptor('switchTab', url, params, callback)
}

/**
 * 关闭所有页面，打开到应用内的某个页面
 * @param {String} url 页面路径
 * @param {Object} params={} 页面参数
 * @param {Object} callback={success,fail,complete} 回调函数
 * @return {Promise} 跳转成功或失败的Promise
 */
export function reLaunch(url, params = {}, callback = {}) {
  return _openInterceptor('reLaunch', url, params, callback)
}

/**
 * 增加版页面返回api
 * 优先级：url > name > delta
 * 其中url、name若传字符串 则是忽略大小写的
 * 方法执行成功后 在返回页面的onShow方法中，直接可以通过this.backParams访问回传的参数
 *
 * @param {Object} option
 * @param {number} option.delta - 直接指定返回几个页面(包括当前页面在内)
 * @param {string|RegExp} option.url - 通过页面路径指定返回页面
 * @param {string|RegExp} option.name - 通过name指定返回页面
 * @param {any} [option.params] - 可选，需要传递回去的参数 根据业务可能为number/string/object/boolean
 * @param {Function} [option.complete] - 可选，完成的回调 无参数 最好使用箭头函数
 *
 * 例如 有如下页面跳转：A->B->C->D
 * 现在在D页面，想返回到A页面，且想给A页面传递参数{ type: 1, id: 'xxxx' },
 * 1. 在D页面合适的位置调用：
 * this.$pi.navi.navigateBack({
 *    delta: 3,
 *    url:'pages/index/index',
 *    params: { type: 1, id: 'xxxx' },
 *    complete: () => {
 *      // TODO 返回到A页面之后 需要再执行某些操作
 *    }
 * })
 *
 * 2. 在A页面中实现onShow这个生命周期
 * export default {
 *    .....
 *    onShow(options) {
 *        if (this.backParams != null) {
 *          // backParams为C页面返回来的参数
 *          // 无需手动清空backParams 会在此次onShow执行完后 自动设置为null
 *        }
 *    }
 * }
 */
export function navigateBack(option = { delta: 1 }) {
  return new Promise(resolve => {
    let delta = option?.delta || 1
    const pages = getCurrentPages() || []
    const isType = (v, t) => {
      return Object.prototype.toString.call(v) === t
    }
    const normalUrl = url => {
      if (/^\//.test(url)) {
        return url.slice(1)
      }
      return url
    }
    const getValue = (target, key) => {
      const keys = key.split('.')
      let val = target
      let i = 0
      while (val && i < keys.length) {
        val = val[keys[i++]]
      }
      return val
    }

    const computeDelta = (val, key) => {
      let reg = null
      if (isType(val, '[object String]')) {
        let url = normalUrl(val)
        reg = new RegExp(`^${url}$`, 'i')
      } else if (isType(val, '[object RegExp]')) {
        reg = val
      }
      if (!reg) {
        console.warn('请检查naviBack方法中的正则表达式')
        return -1
      }
      const pageIndex = pages.findIndex(p => reg.test(getValue(p, key)))
      if (pageIndex === -1) {
        if (key === 'route') {
          console.warn('当前路由不存在，请检查naviBack方法的url是否正确')
        } else {
          console.warn('当前路由不存在，请检查naviBack方法的name是否正确')
        }
        return -1
      }
      const result = pages.length - 1 - pageIndex
      return result
    }
    if (option?.url) {
      delta = computeDelta(option.url, 'route')
    } else if (option?.name) {
      delta = computeDelta(option.name, '$vm.$options.name')
    } else {
      delta = option?.delta || 1
    }
    if (delta === -1) {
      resolve(false)
      return
    }
    if (delta < pages.length) {
      const targetPage = pages[pages.length - 1 - delta]
      targetPage.$vm.backParams = null
      let preCallback = () => {
        targetPage.$vm.backParams = option.params
      }
      let postCallback = oldOnShow => {
        targetPage.$vm.backParams = undefined
        targetPage.onShow = oldOnShow
      }
      if (targetPage.onShow && targetPage.$vm.$options.onShow?.length > 0) {
        const oldOnShow = targetPage.onShow
        const newOnShow = (...args) => {
          preCallback()
          oldOnShow.apply(targetPage, args)
          postCallback(oldOnShow)
        }
        targetPage.onShow = newOnShow
      }
      const isH5 = targetPage.$vm === targetPage
      if (isH5) {
        preCallback()
      }
      uni.navigateBack({
        delta,
        complete: () => {
          if (option.complete) {
            option.complete()
          }
          resolve(true)
          if (isH5) {
            setTimeout(() => {
              postCallback()
            }, 10)
          }
        }
      })
    } else {
      resolve(false)
    }
  })
}

export default {
  objToUrl,
  urlToObj,
  decodeParams,
  navigateTo,
  redirectTo,
  switchTab,
  reLaunch,
  navigateBack
}
